<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>åƒç´ ç”»ç¼–è¾‘å™¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Segoe UI, Arial, sans-serif;
            min-height: 100vh;
            padding: 20px
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.2em
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap
        }

        .canvas-area {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative
        }

        .remap-cell {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .remap-cell.selected {
            outline: 2px solid #ff9800;
        }

        #canvasWrapper {
            position: relative;
        }

        #canvas {
            border: 3px solid #667eea;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            display: inline-grid;
            cursor: crosshair;
            user-select: none;
        }

        #previewLayer {
            position: absolute;
            top: 3px;
            left: 3px;
            pointer-events: none;
            z-index: 40
        }

        #selectionLayer {
            position: absolute;
            top: 3px;
            left: 3px;
            pointer-events: none;
            z-index: 50
        }

        .pixel {
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: opacity .08s
        }

        .control-panel {
            width: 360px;
            display: flex;
            flex-direction: column;
            gap: 4px
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            .main-content {
                flex-direction: column;
                gap: 15px;
            }

            .canvas-area {
                min-width: 100%;
                width: 100%;
            }

            .control-panel {
                width: 100%;
            }

            .panel-section {
                padding: 8px;
            }

            .panel-section h3 {
                font-size: 0.9em;
                margin-bottom: 8px;
            }

            button {
                padding: 8px 12px;
                font-size: 13px;
            }

            .color-btn {
                width: 30px;
                height: 30px;
            }

            #helpSection {
                font-size: 13px;
                padding: 10px 12px;
            }

            #helpSection h2 {
                font-size: 1.1em;
            }

            #helpSection ul {
                padding-left: 18px;
            }

            #helpSection li {
                margin-bottom: 6px;
            }

            textarea {
                min-height: 100px;
                font-size: 12px;
            }

            #toyAvatar {
                width: 60px;
                height: 60px;
                right: 12px;
                bottom: 12px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 10px;
                border-radius: 12px;
            }

            h1 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }

            .btn-group {
                gap: 6px;
            }

            button {
                padding: 6px 10px;
                font-size: 12px;
            }

            .color-btn {
                width: 28px;
                height: 28px;
            }

            .remap-cell {
                width: 26px;
                height: 26px;
            }

            #helpSection {
                font-size: 12px;
                padding: 8px 10px;
            }

            #toyAvatar {
                width: 50px;
                height: 50px;
                right: 10px;
                bottom: 10px;
            }
        }

        .panel-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1)
        }

        .panel-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1em
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px
        }

        button {
            padding: 7px 14px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
            position: relative
        }

        button.active {
            background: #764ba2;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.15)
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px
        }

        .color-btn {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: 3px solid transparent;
            cursor: pointer
        }

        .color-btn.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: monospace
        }

        .size-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #ddd
        }

        .small-note {
            font-size: 12px;
            color: #666;
            margin-top: 8px
        }

        /* é€‰åŒºæ ·å¼ï¼šæ©™è‰²åŠé€æ˜æ–œçº¿ */
        .sel-pixel {
            position: absolute;
            pointer-events: none;
            background-image: repeating-linear-gradient(135deg, rgba(255, 165, 0, 0.25) 0 6px, transparent 6px 12px);
            mix-blend-mode: normal;
            z-index: 50;
        }

        .sel-border {
            position: absolute;
            pointer-events: none;
            border: 1px dashed rgba(255, 140, 0, 0.95);
            box-sizing: border-box;
            z-index: 55;
        }

        .sel-preview {
            position: absolute;
            pointer-events: none;
            background-image: repeating-linear-gradient(135deg, rgba(255, 165, 0, 0.18) 0 6px, transparent 6px 12px);
            z-index: 49;
            box-sizing: border-box;
        }

        /* hover tooltip (simple) */
        button[title]:hover::after {
            content: attr(title);
            position: absolute;
            left: 50%;
            transform: translate(-50%, -140%);
            background: rgba(0, 0, 0, 0.78);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 12px;
            z-index: 80;
        }

        .no-grid .pixel {
            border: none !important;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            text-align: center;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .toast.show {
            opacity: 1;
        }
    /* å¤´åƒå®¹å™¨ï¼ˆå³ä¸‹è§’å›ºå®šï¼‰ */
    #toyAvatar {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 72px;
      height: 72px;
      border-radius: 18px;
      background: linear-gradient(180deg,#ffecec,#ffd9d9);
      box-shadow: 0 8px 22px rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:9999;
      transform-origin: center;
      transition: transform 120ms ease, box-shadow 120ms ease;
      user-select:none;
    }

    #toyAvatar .face {
      width:64%; height:64%;
      display:block;
    }
    @keyframes squeeze {
      0% { transform: scale(1,1); }
      20% { transform: scale(1.14, 0.78); }
      55% { transform: scale(0.95, 1.05); }
      100% { transform: scale(1,1); }
    }
    #toyAvatar.squeeze {
      animation: squeeze 360ms cubic-bezier(.2,.9,.3,1);
    }
    #toyAvatar:active { box-shadow: 0 4px 10px rgba(0,0,0,0.28); }
    #toyAvatar .hint {
      position:absolute;
      right:25%;
      bottom:150%;
      margin-bottom:6px;
      background:rgba(0,0,0,0.75);
      color:#fff;
      padding:6px 8px;
      border-radius:6px;
      font-size:12px;
      white-space:nowrap;
      opacity:0;
      transform: translateY(6px);
      transition:opacity .12s, transform .12s;
      pointer-events:none;
    }
    #toyAvatar:hover .hint { opacity:1; transform: translateY(0); }

    </style>
</head>
<body>
<div class="container">
    <h1>ğŸ¨ åƒç´ ç”»ç¼–è¾‘å™¨</h1>
    <div class="main-content">
        <div class="canvas-area">
            <div id="canvasWrapper">
                <div id="canvas"></div>
                <div id="previewLayer"></div>
                <div id="selectionLayer"></div>
            </div>
            <!-- ğŸ“ ä½¿ç”¨è¯´æ˜åŒºåŸŸ -->
            <div id="helpSection" style="margin-top:20px;padding:12px 16px;border-radius:8px;
            background:#f9fafc;border:1px solid #d0d4e4;max-width:800px;line-height:1.6;">
                <h2 style="margin-top:0;">ğŸ§­ ä½¿ç”¨è¯´æ˜</h2>
                <ul style="margin:0;padding-left:20px;">
                    <li><b>æŒ‰é”®å¿«æ·é”®</b>ï¼šç¬”åˆ· B, æ©¡çš®æ“¦ E, å–è‰² Alt, å¡«å…… F, é€‰åŒº M, ç½‘æ ¼ G</li>
                    <li><b>æ’¤å›ä¸é‡åš</b>ï¼šCtrl + Z æ’¤å› Ctrl + Y é‡åš</li>
                    <li><b>é€‰åŒº</b>ï¼šé•¿æŒ‰æ‹–åŠ¨é€‰å–ï¼Œç²˜è´´åå¯æ‹–åŠ¨,Shift + æ‹–åŠ¨ å åŠ é€‰åŒºã€‚æŒ‰ Enter æ”¾ç½®, Esc å–æ¶ˆ</li>
                    <li>â€”â€”é€‰åŒºæ”¯æŒçŸ©å½¢å’Œæ‰‹æ¶‚ä¸¤ç§æ–¹å¼ï¼›æ‰‹æ¶‚é€‰å–ä¸ºé€åƒç´ åˆ‡æ¢é€‰ä¸­çŠ¶æ€ã€‚</li>
                    <li><b>Ctrl + C / X / V</b>ï¼šå¤åˆ¶ / å‰ªåˆ‡ / ç²˜è´´é€‰åŒº</li>
                    <li><b>å¯¹ç§°æ¨¡å¼</b>ï¼šå°†ç»˜åˆ¶æ“ä½œå¯¹ç§°ï¼Œè¯•è¯•å°±çŸ¥é“äº†</li>
                    <li><b>è°ƒè‰²æ¿</b>ï¼šå› ä¸ºæ˜¯åšè¿›åœ°å›¾é‡Œçš„æ‰€ä»¥æ²¡æ³•å¾ˆå¤æ‚ï¼Œå°±16ç§é¢œè‰²ï¼Œå‘æŒ¥æƒ³è±¡åŠ›å§()</li>
                    <li><b>é¢œè‰²é‡æ˜ å°„</b>ï¼šç‚¹å‡»ä¸¤ä¸ªé¢œè‰²è¿›è¡Œäº’æ¢, å°†é¢œè‰²é‡æ–°æ˜ å°„ã€‚ğŸ²éšæœºæ‰“ä¹±é¢œè‰²ï¼Œâ†©ï¸æ¢å¤åŸå§‹é¢œè‰²æ˜ å°„</li>
                    <li><b>å¯¼å…¥å¯¼å‡º</b>ï¼šç‚¹å‡»å³ä¾§å¯¼å‡ºè‡ªåŠ¨å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå¯¼å…¥ä¼šä»è¾“å…¥æ¡†è¯»å–ï¼Œæ²¡æœ‰å°±ä»å‰ªè´´æ¿æ‹¿</li>
                    <li><b>å¯¼å…¥å›¾ç‰‡</b>ï¼šä½¿ç”¨å°±è¿‘é¢œè‰²å’Œåƒç´ å¼ºåˆ¶æŠŠå›¾ç‰‡ç¼©æ”¾åˆ°ç”»å¸ƒä¸Š</li>
                </ul>
                <p style="margin-top:10px;color:#555;">
                    ğŸ’¡ æç¤ºï¼šè™½ç„¶ç½‘é¡µå…³é—­æ—¶ä¼šè‡ªåŠ¨ä¿å­˜ï¼Œè¿˜è¯·æ‰‹åŠ¨ä¿å­˜é˜²æ­¢ä¸¢å¤±
                </p>
            </div>
        </div>

        <div class="control-panel">
            <div class="panel-section">
                <h3>å·¥å…·</h3>
                <div class="btn-group">
                    <button id="pen" class="active" title="ç”»ç¬” B">ğŸ–Œï¸ ç”»ç¬”</button>
                    <button id="eraser" title="æ©¡çš®æ“¦ E">ğŸ§¹ æ©¡çš®æ“¦</button>
                    <button id="eyedropper" title="å–è‰² Alt">ğŸ¯ å–è‰²</button>
                    <button id="line" title="ç›´çº¿">ğŸ“ ç›´çº¿</button>
                    <button id="rect" title="çŸ©å½¢">â¬› çŸ©å½¢</button>
                    <button id="circle" title="åœ†å½¢">âšª åœ†å½¢</button>
                    <button id="fill" title="å¡«å…… F">ğŸ’§ å¡«å……</button>
                    <button id="undo" title="æ’¤å› Ctrl+Z">â†©ï¸ æ’¤å›</button>
                    <button id="redo" title="é‡åš Ctrl+Y">â†ªï¸ é‡åš</button>
                    <button id="clear" style="background:#e74c3c" title="æ¸…ç©º">ğŸ—‘ï¸ æ¸…ç©º</button>
                    <button id="toggleGrid" title="æ˜¾ç¤º/éšè—ç½‘æ ¼ G">ğŸ§© ç½‘æ ¼</button>
                </div>
                <div style="margin-top:12px">
                    <strong>é€‰åŒº</strong>
                    <div class="btn-group" style="margin-top:8px">
                        <button id="selRect" title="çŸ©å½¢é€‰å– M (Shift å åŠ )">â–­ çŸ©å½¢é€‰å–</button>
                        <button id="selFree" title="æ‰‹æ¶‚é€åƒç´ é€‰å–ï¼ˆå†æ¬¡æ¶‚åˆ™å–æ¶ˆï¼‰">âœï¸ æ‰‹æ¶‚é€‰å–</button>
                        <button id="selMove" title="ç§»åŠ¨é€‰åŒº (å‰ªåˆ‡å¹¶ç²˜è´´)">â¤´ï¸ ç§»åŠ¨</button>
                        <button id="selCopy" title="å¤åˆ¶é€‰åŒº Ctrl+C">ğŸ“„ å¤åˆ¶</button>
                        <button id="selCut" title="å‰ªåˆ‡é€‰åŒº Ctrl+X">âœ‚ï¸ å‰ªåˆ‡</button>
                        <button id="selPaste" title="ç²˜è´´ Ctrl+V">ğŸ“Œ ç²˜è´´</button>
                        <button id="selClear" title="æ¸…é™¤é€‰åŒº Esc">âœ–ï¸ æ¸…é™¤é€‰åŒº</button>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>å¯¹ç§°æ¨¡å¼</h3>
                <div class="btn-group">
                    <button class="symmetry-btn" data-mode="none" title="æ— å¯¹ç§°">æ— å¯¹ç§°</button>
                    <button class="symmetry-btn" data-mode="horizontal" title="æ°´å¹³é•œåƒ">æ°´å¹³é•œåƒ</button>
                    <button class="symmetry-btn" data-mode="vertical" title="ç«–ç›´é•œåƒ">ç«–ç›´é•œåƒ</button>
                    <button class="symmetry-btn" data-mode="both" title="åŒå‘é•œåƒ">åŒå‘é•œåƒ</button>
                    <button class="symmetry-btn" data-mode="rotate4" title="4å‘æ—‹è½¬">4å‘æ—‹è½¬</button>
                    <button class="symmetry-btn" data-mode="rotate8" title="8å‘æ—‹è½¬">8å‘æ—‹è½¬</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>è°ƒè‰²æ¿</h3>
                <div class="color-palette" id="colorPalette"></div>
                <div style="display:flex;gap:10px;margin-top:10px">
                    <!--input type="color" id="colorPicker" value="#000000"-->
                    <!--button id="addColor" title="æ·»åŠ é¢œè‰²">â• æ·»åŠ </button-->
                </div>
                <div id="paletteRemap" style="margin-top:12px;padding:10px;border:1px solid #ccc;border-radius:8px;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
                        <strong>ğŸ¨ é¢œè‰²é‡æ˜ å°„ï¼š</strong>
                        <button id="shuffleColors" title="éšæœºæ‰“ä¹±è°ƒè‰²æ¿é¡ºåº">ğŸ²</button>
                        <button id="resetRemap" title="æ¢å¤åŸå§‹é¡ºåº">â†©ï¸</button>
                    </div>
                    <div id="remapGrid"
                         style="display:grid;grid-template-columns:repeat(auto-fill, 30px);gap:8px;"></div>
                    <small style="color:#666;">ç‚¹å‡»ä¸¤ä¸ªé¢œè‰²äº¤æ¢å®ƒä»¬çš„æ˜ å°„, æˆ–ä½¿ç”¨ ğŸ² éšæœºæ‰“ä¹±ã€‚</small>
                </div>

            </div>

            <div class="panel-section">
                <h3>å¯¼å‡º/å¯¼å…¥</h3>
                <div class="btn-group" style="margin-bottom:10px">
                    <button id="exportBtn" style="flex:1">ğŸ“‹ å¯¼å‡º/å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
                    <button id="importBtn" style="flex:1;background:#27ae60">ğŸ“¥ å¯¼å…¥/ä»å‰ªè´´æ¿å¯¼å…¥</button>
                    <button id="importImage" title="å¯¼å…¥å›¾ç‰‡">ğŸ–¼ å¯¼å…¥å›¾ç‰‡</button>
                </div>
                <textarea id="exportOutput" placeholder="å¯¼å‡ºçš„åƒç´ ç”»æ•°æ®ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                <div style="margin-top:8px;font-size:12px;color:#666">ğŸ’¡ æ¯ä¸€è¡Œå½¢å¦‚ <code>- [0, 1, 2, ...]</code>,
                    æ¯ä¸ªæ•°å­—ä»£è¡¨é¢œè‰²åœ¨è°ƒè‰²æ¿ä¸­çš„åºå·ï¼ˆ0-Fï¼‰, ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹æ’åˆ—ã€‚
                </div>
            </div>
            <!--div class="panel-section">
              <h3>ç”»å¸ƒå¤§å°</h3>
              <div class="size-controls">
                <label>å®½:</label>
                <input type="number" id="canvasWidth" value="45" min="5" max="100">
                <label>é«˜:</label>
                <input type="number" id="canvasHeight" value="45" min="5" max="100">
              </div>
              <button id="resizeCanvas" style="margin-top:10px;width:100%">åº”ç”¨å°ºå¯¸</button>
            </div-->
            <div class="panel-section">
                <h3>
                    ä½œå“æäº¤
                </h3>
                <button onclick="window.open('https://wj.qq.com/s2/24356581/974c/', '_blank')">ç‚¹å‡»å‰å¾€æäº¤é—®å·</button>
            </div>
            <div class="panel-section">
                <h3>
                    è§‚çœ‹ç›´æ’­è§£é”æ›´å¤šåŠŸèƒ½
                </h3>
                <button id="unlock" style="margin-top:10px;width:100%" onclick="handleUnlockClick()">å‰å¾€ç›´æ’­é—´</button>
            </div>
        </div>
    </div>
</div>
<script>
// æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
function isMobileDevice() {
    return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
}

// å¦‚æœæ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œåˆ™é‡å®šå‘åˆ°æç¤ºé¡µé¢
if (isMobileDevice()) {
    alert("åƒç´ ç”»ç¼–è¾‘å™¨ä¸æ”¯æŒç§»åŠ¨è®¾å¤‡è®¿é—®ï¼Œéƒ¨åˆ†å·¥å…·ä¼šæ— æ³•ä½¿ç”¨ï¼Œè¯·ä½¿ç”¨æ¡Œé¢æµè§ˆå™¨è·å¾—å®Œæ•´ä½“éªŒ");
}
/* ====== åŸºç¡€é…ç½® ====== */
let COLS = 45, ROWS = 45;
let PIXEL_SIZE = 10;
const MAX_HISTORY = 500;

/* ====== çŠ¶æ€ ====== */
let currentColor = "#000000";
let tool = "pen";
let symmetryMode = "none";

let previousTool = null;   // ç”¨æ¥ä¸´æ—¶è®°ä½ä¸Šä¸€ä¸ªå·¥å…·
let isColorPicking = false;

/* ====== é€‰åŒºçŠ¶æ€ï¼ˆæ›¿æ¢é€»è¾‘ï¼‰ ====== */
let selectionMode = null; // 'rect' | 'free' | 'move' | 'paste' | null
let selectionPixels = new Set(); // "x,y"
let selectionBounds = null;
let clipboard = null; // {w,h,cells}
let pasteOffset = null; // {x,y}
let moveOrigin = null; // for move: array of {x,y,oldColor}
let isSelecting = false, isDraggingPaste = false;
let lastToggledKey = null;

/* ====== æ•°æ®ç»“æ„ ====== */
let colorPalette = [
    "#FFFFFF", "#D3D3D3", "#808080", "#000000",
    "#B02E26", "#5E7C16", "#835432", "#3C44AA",
    "#8932B8", "#169C9C", "#F38BAA", "#80C71F",
    "#FED83D", "#3AB3DA", "#C74EBD", "#F9801D"
];

let pixelData = [];           // ROWS x COLS çš„é¢œè‰²å€¼
let historyStack = [];        // å†å²
let redoStack = [];
let currentStep = null;       // ä¸´æ—¶è®°å½•

let moveBackup = null;   // å­˜æ”¾ç§»åŠ¨å‰çš„åƒç´ æ•°æ®
let isMoving = false;    // æ ‡è¯†å½“å‰æ˜¯å¦åœ¨ç§»åŠ¨

let currentMousePos = {x: 0, y: 0}


/* ====== DOM å…ƒç´  ====== */
const canvas = document.getElementById("canvas");
const canvasWrapper = document.getElementById("canvasWrapper");
const previewLayer = document.getElementById("previewLayer");
const selectionLayer = document.getElementById("selectionLayer");
const colorPaletteContainer = document.getElementById("colorPalette");
const exportOutput = document.getElementById("exportOutput");

/* ====== åˆ‡æ¢å·¥å…· ======*/
function setActiveTool(toolName) {
    tool = toolName;
    document.querySelectorAll(".btn-group button").forEach(b => b.classList.remove("active"));
    const btn = document.getElementById(toolName);
    if (btn) btn.classList.add("active");
    refreshSymmetry()
}

function refreshSymmetry() {
    document.querySelectorAll(".symmetry-btn").forEach(b => {
        if (b.dataset.mode === symmetryMode) {
            b.classList.add("active")
        } else {
            b.classList.remove("active")
        }
    });
}

function setActiveSelection(btnId) {
    document.querySelectorAll('#selRect,#selFree').forEach(b => b.classList.remove('active'));
    const btn = document.getElementById(btnId);
    if (btn) btn.classList.add('active');
    refreshSymmetry()
}

/* ====== åˆå§‹åŒ–æ•°æ®/ç”»å¸ƒ ====== */
function initData() {
    pixelData = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => colorPalette[0]));
}

function resizeWrapper() {
    PIXEL_SIZE = Math.min(Math.min(window.innerWidth * 0.0125, window.innerHeight * 0.03), 20) || 10
    canvas.style.gridTemplateColumns = `repeat(${COLS}, ${PIXEL_SIZE}px)`;
    canvas.style.gridTemplateRows = `repeat(${ROWS}, ${PIXEL_SIZE}px)`;
    canvas.style.width = (COLS * PIXEL_SIZE) + "px";
    canvas.style.height = (ROWS * PIXEL_SIZE) + "px";
    canvasWrapper.style.width = (COLS * PIXEL_SIZE + 18) + "px";
    canvasWrapper.style.height = (ROWS * PIXEL_SIZE + 18) + "px";
    previewLayer.style.width = (COLS * PIXEL_SIZE) + "px";
    previewLayer.style.height = (ROWS * PIXEL_SIZE) + "px";
    selectionLayer.style.width = (COLS * PIXEL_SIZE) + "px";
    selectionLayer.style.height = (ROWS * PIXEL_SIZE) + "px";
    document.querySelectorAll(".pixel").forEach(p => {
        p.style.width = `${PIXEL_SIZE}px`;
        p.style.height = `${PIXEL_SIZE}px`;
    });
}

window.addEventListener("resize", resizeWrapper);

function initCanvas() {
    canvas.innerHTML = "";
    resizeWrapper();

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            const d = document.createElement("div");
            d.className = "pixel";
            d.dataset.x = x;
            d.dataset.y = y;
            d.style.width = PIXEL_SIZE + "px";
            d.style.height = PIXEL_SIZE + "px";
            d.style.backgroundColor = pixelData[y][x];
            canvas.appendChild(d);
        }
    }
    renderSelectionLayer();
}

// === é¢œè‰²é‡æ˜ å°„ ===
// basePalette: åˆå§‹è°ƒè‰²æ¿ï¼ˆä¸å˜, ç”¨ä½œâ€œç´¢å¼•åŸºå‡†â€ï¼‰
// currentMapping: å½“å‰ mapping çŠ¶æ€ï¼ˆcurrentMapping[i] = å½“å‰æ˜¾ç¤ºä¸ºåŸå§‹ç´¢å¼• i çš„é¢œè‰²ï¼‰
let basePalette = colorPalette.slice();     // å–å½“å‰ä¸»è°ƒè‰²æ¿å¿«ç…§ï¼ˆè°ƒç”¨ initRemapPanel æ—¶é‡æ–°è®¾ï¼‰
let currentMapping = basePalette.slice();   // å½“å‰ index -> color æ˜ å°„ï¼ˆåˆå§‹æ—¶ä¸º identityï¼‰
let remapSelected = null;

// åˆå§‹åŒ– / æ¸²æŸ“ remap é¢æ¿ï¼ˆè°ƒç”¨ä½ç½®ï¼šrenderColorPalette() åæˆ– init æ—¶ï¼‰
function initRemapPanel() {
    // å¦‚æœè°ƒè‰²æ¿å˜äº†ï¼ˆæ–°å¢é¢œè‰²ï¼‰, é‡ç½® basePalette, ä¿æŒé•¿åº¦ä¸€è‡´
    basePalette = colorPalette.slice();
    if (!currentMapping || currentMapping.length !== basePalette.length) currentMapping = basePalette.slice();

    const grid = document.getElementById("remapGrid");
    if (!grid) return; // å¦‚æœ DOM æ²¡æœ‰è¿™ä¸ªå®¹å™¨å°±ç›´æ¥è¿”å›
    grid.innerHTML = "";
    basePalette.forEach((c, idx) => {
        const cell = document.createElement("div");
        cell.className = "remap-cell";
        cell.style.backgroundColor = currentMapping[idx];
        cell.dataset.index = idx;
        cell.addEventListener("click", () => onRemapClick(idx, cell));
        grid.appendChild(cell);
    });
}

// åˆ·æ–° remap é¢æ¿æ˜¾ç¤ºï¼ˆé¢œè‰²/é€‰ä¸­çŠ¶æ€ï¼‰
function refreshRemapGrid() {
    const grid = document.getElementById("remapGrid");
    if (!grid) return;
    grid.querySelectorAll(".remap-cell").forEach(cell => {
        const idx = Number(cell.dataset.index);
        cell.style.backgroundColor = currentMapping[idx];
        cell.classList.remove("selected");
    });
    remapSelected = null;
}

/*
 applyPaletteMapping(newMapping)
  - newMapping: é•¿åº¦å¿…é¡»ç­‰äº basePalette.length
  - å·¥ä½œæ–¹å¼ï¼šåŸºäº currentMappingï¼ˆå½“å‰æ˜¾ç¤ºé¢œè‰²ï¼‰å»ºåè¡¨ currentColor -> originalIndex
    å¯¹ç”»å¸ƒæ¯åƒç´ æŸ¥åˆ° originalIndex åç”¨ newMapping[index] æ›¿æ¢åƒç´ é¢œè‰²
  - è®°å½•å·®å¼‚å¹¶ pushHistory, ä½¿æ“ä½œå¯æ’¤å›
*/
function applyPaletteMapping(newMapping) {
    if (!Array.isArray(newMapping) || newMapping.length !== basePalette.length) {
        console.warn("remap length mismatch", newMapping, basePalette);
        return;
    }

    // åå‘è¡¨ï¼šå½“å‰æ˜¾ç¤ºé¢œè‰² -> original index
    const reverse = new Map();
    for (let i = 0; i < currentMapping.length; i++) {
        reverse.set(currentMapping[i], i);
    }

    const step = []; // ç”¨äºæ’¤å›
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            const oldColor = pixelData[y][x];
            const idx = reverse.has(oldColor) ? reverse.get(oldColor) : undefined;
            if (typeof idx === "number") {
                const newColor = newMapping[idx];
                if (newColor !== oldColor) {
                    step.push({x, y, oldColor, newColor});
                    // ç›´æ¥å†™ DOM & æ•°æ®
                    setPixelDirect(x, y, newColor);
                }
            }
            // å¦‚æœè¯¥åƒç´ ä¸æ˜¯è°ƒè‰²æ¿é¢œè‰²ï¼ˆæœªåœ¨ reverse ä¸­ï¼‰, åˆ™ä¿æŒä¸å˜
        }
    }

    if (step.length > 0) pushHistory(step); // æ”¯æŒæ’¤å›
    currentMapping = newMapping.slice();     // æ›´æ–°å½“å‰ mapping çŠ¶æ€
    refreshRemapGrid();
}

// ç‚¹å‡» remap å•å…ƒæ ¼ï¼šå®ç°â€œé€‰ä¸¤ä¸ªæ ¼å­äº’æ¢æ˜ å°„å¹¶ç«‹å³åº”ç”¨â€
function onRemapClick(idx, cell) {
    if (remapSelected === null) {
        remapSelected = idx;
        cell.classList.add("selected");
        return;
    }
    if (remapSelected === idx) {
        // å–æ¶ˆé€‰æ‹©
        cell.classList.remove("selected");
        remapSelected = null;
        return;
    }

    // äº¤æ¢ currentMapping çš„ä¸¤ä¸ªä½ç½®å¹¶åº”ç”¨
    const newMap = currentMapping.slice();
    [newMap[idx], newMap[remapSelected]] = [newMap[remapSelected], newMap[idx]];
    remapSelected = null;
    applyPaletteMapping(newMap);
}

// éšæœºæ‰“ä¹±ï¼ˆFisher-Yatesï¼‰, å¹¶åº”ç”¨åˆ°ç”»å¸ƒï¼ˆå¯æ’¤å›ï¼‰
document.getElementById("shuffleColors").addEventListener("click", () => {
    const newMap = currentMapping.slice();
    for (let i = newMap.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newMap[i], newMap[j]] = [newMap[j], newMap[i]];
    }
    applyPaletteMapping(newMap);
});

// æ¢å¤åŸå§‹é¡ºåºï¼ˆæŠŠ mapping è¿˜åŸä¸º basePalette, ç„¶ååº”ç”¨ï¼‰
document.getElementById("resetRemap").addEventListener("click", () => {
    applyPaletteMapping(basePalette.slice());
});

// å¦‚æœä½ åœ¨â€œæ·»åŠ é¢œè‰²â€æ—¶æ‰©å±•äº† colorPalette, è¯·åœ¨æ·»åŠ åè°ƒç”¨ initRemapPanel()
// ä¾‹å¦‚ï¼šaddColor æŒ‰é’®æˆåŠŸåŠ å…¥åè°ƒç”¨ initRemapPanel();


/* ====== å¯¹ç§°ç‚¹ ====== */
function getSymmetryPoints(x, y) {
    const points = [{x, y}];
    const centerX = (COLS - 1) / 2;
    const centerY = (ROWS - 1) / 2;
    switch (symmetryMode) {
        case "horizontal":
            points.push({x: COLS - 1 - x, y});
            break;
        case "vertical":
            points.push({x, y: ROWS - 1 - y});
            break;
        case "both":
            points.push({x: COLS - 1 - x, y});
            points.push({x, y: ROWS - 1 - y});
            points.push({x: COLS - 1 - x, y: ROWS - 1 - y});
            break;
        case "rotate4": {
            const dx = x - centerX, dy = y - centerY;
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY - dx)});
            break;
        }
        case "rotate8": {
            const dx = x - centerX, dy = y - centerY;
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY - dx)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY - dx)});
            points.push({x: Math.round(centerX + dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY + dy)});
            break;
        }
    }
    const seen = new Set();
    return points.filter(p => {
        if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS) return false;
        const k = `${p.x},${p.y}`;
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
    });
}

/* ====== åƒç´ å†™å…¥ ====== */
function setPixelDirect(x, y, color) {
    pixelData[y][x] = color;
    const pixel = canvas.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
    if (pixel) pixel.style.backgroundColor = color;
}

function drawPixel(x, y, colorOverride = null) {
    const color = colorOverride || ((tool === "eraser") ? colorPalette[0] : currentColor);
    const pts = getSymmetryPoints(x, y);
    pts.forEach(p => {
        const oldColor = pixelData[p.y][p.x];
        if (oldColor === color) return;
        if (currentStep) currentStep.push({x: p.x, y: p.y, oldColor, newColor: color});
        setPixelDirect(p.x, p.y, color);
    });
}

/* ====== é€‰åŒºï¼šæ¸²æŸ“ä¸å·¥å…·ï¼ˆå®Œå…¨æ›¿æ¢ï¼‰ ====== */
function updateSelectionBounds() {
    if (selectionPixels.size === 0) {
        selectionBounds = null;
        return;
    }
    let minX = COLS, minY = ROWS, maxX = 0, maxY = 0;
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
    });
    selectionBounds = {minX, minY, maxX, maxY};
}

function renderSelectionLayer() {
    selectionLayer.innerHTML = "";
    // ç²˜è´´/ç§»åŠ¨é¢„è§ˆä¼˜å…ˆæ˜¾ç¤ºï¼ˆé¢œè‰²å— + æ–œçº¿è¦†ç›–ï¼‰
    if (clipboard && pasteOffset) {
        for (let sy = 0; sy < clipboard.h; sy++) {
            for (let sx = 0; sx < clipboard.w; sx++) {
                const col = clipboard.cells[sy][sx];
                if (col == null) continue;
                const x = pasteOffset.x + sx, y = pasteOffset.y + sy;
                if (x < 0 || x >= COLS || y < 0 || y >= ROWS) continue;
                const el = document.createElement('div');
                el.className = 'sel-preview';
                el.style.left = (x * PIXEL_SIZE) + 'px';
                el.style.top = (y * PIXEL_SIZE) + 'px';
                el.style.width = (PIXEL_SIZE) + 'px';
                el.style.height = (PIXEL_SIZE) + 'px';
                el.style.backgroundColor = col;
                selectionLayer.appendChild(el);
            }
        }
        // è¾¹æ¡†
        const border = document.createElement('div');
        border.className = 'sel-border';
        border.style.left = (pasteOffset.x * PIXEL_SIZE) + 'px';
        border.style.top = (pasteOffset.y * PIXEL_SIZE) + 'px';
        border.style.width = (clipboard.w * PIXEL_SIZE) + 'px';
        border.style.height = (clipboard.h * PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(border);
        return;
    }

    // å¸¸è§„é€‰åŒºæ¯åƒç´ æ˜¾ç¤ºæ–œçº¿
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        const el = document.createElement('div');
        el.className = 'sel-pixel';
        el.style.left = (x * PIXEL_SIZE) + 'px';
        el.style.top = (y * PIXEL_SIZE) + 'px';
        el.style.width = (PIXEL_SIZE) + 'px';
        el.style.height = (PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(el);
    });
    if (selectionBounds) {
        const b = selectionBounds;
        const border = document.createElement('div');
        border.className = 'sel-border';
        border.style.left = (b.minX * PIXEL_SIZE) + 'px';
        border.style.top = (b.minY * PIXEL_SIZE) + 'px';
        border.style.width = ((b.maxX - b.minX + 1) * PIXEL_SIZE) + 'px';
        border.style.height = ((b.maxY - b.minY + 1) * PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(border);
    }
}

function setSelectionFromRect(x1, y1, x2, y2, add = false) {
    if (!add) selectionPixels.clear();
    const minX = Math.max(0, Math.min(x1, x2));
    const maxX = Math.min(COLS - 1, Math.max(x1, x2));
    const minY = Math.max(0, Math.min(y1, y2));
    const maxY = Math.min(ROWS - 1, Math.max(y1, y2));
    for (let y = minY; y <= maxY; y++) for (let x = minX; x <= maxX; x++) selectionPixels.add(`${x},${y}`);
    updateSelectionBounds();
    renderSelectionLayer();
}

/* æ‰‹æ¶‚é€‰åŒºï¼šé€åƒç´ åˆ‡æ¢ï¼ˆæŒ‰ä¸‹å¹¶æ‹–åŠ¨ä¼šæŒ‰æ ¼åˆ‡æ¢ä¸€æ¬¡ï¼‰ */
function toggleSelectionPixel(x, y) {
    const k = `${x},${y}`;
    if (selectionPixels.has(k)) selectionPixels.delete(k);
    else selectionPixels.add(k);
    updateSelectionBounds();
    renderSelectionLayer();
}

/* å‰ªè´´æ¿æ“ä½œ */
function copySelection() {
    if (!selectionBounds) return alert('æ²¡æœ‰é€‰åŒº');
    const b = selectionBounds;
    const w = b.maxX - b.minX + 1, h = b.maxY - b.minY + 1;
    const cells = Array.from({length: h}, () => Array.from({length: w}, () => null));
    for (let y = b.minY; y <= b.maxY; y++) {
        for (let x = b.minX; x <= b.maxX; x++) {
            const k = `${x},${y}`;
            if (selectionPixels.has(k)) cells[y - b.minY][x - b.minX] = pixelData[y][x];
            else cells[y - b.minY][x - b.minX] = null;
        }
    }
    clipboard = {w, h, cells};
    pasteOffset = {x: b.minX, y: b.minY};
    // clear moveOrigin if any
    moveOrigin = null;
    renderSelectionLayer();
}

function cutSelection() {
    if (!selectionBounds) return alert('æ²¡æœ‰é€‰åŒº');
    copySelection();
    const toColor = colorPalette[0];
    const step = [];
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        step.push({x, y, oldColor: pixelData[y][x], newColor: toColor});
        setPixelDirect(x, y, toColor);
    });
    pushHistory(step);
    selectionPixels.clear();
    updateSelectionBounds();
    renderSelectionLayer();
}

/* å¼€å§‹ç²˜è´´ï¼ˆæˆ–ç§»åŠ¨ï¼‰é¢„è§ˆ â€” ç²˜è´´ç”± beginPaste() å¯åŠ¨, å›è½¦ applyPaste() */
function beginPaste() {
    if (!clipboard) return alert('å‰ªè´´æ¿ä¸ºç©º');

    // currentMousePos åº”è¯¥æ˜¯ç”»å¸ƒæ ¼åæ ‡ {x, y}ï¼ˆä¸æ˜¯ clientX/clientYï¼‰
    const pos = (typeof currentMousePos !== 'undefined' && currentMousePos) ? currentMousePos : null;

    // æƒ³æŠŠç²˜è´´åŒºåŸŸâ€œå±…ä¸­æ”¾åˆ°é¼ æ ‡å¤„â€, è®¡ç®—æœŸæœ›çš„å·¦ä¸Šè§’
    const desiredX = pos ? (pos.x - Math.floor(clipboard.w / 2)) : (selectionBounds ? selectionBounds.minX : 0);
    const desiredY = pos ? (pos.y - Math.floor(clipboard.h / 2)) : (selectionBounds ? selectionBounds.minY : 0);

    // æœ€å¤§å…è®¸çš„åç§»ï¼ˆé˜²æ­¢è¶Šç•Œï¼‰, è‹¥ clipboard æ¯”ç”»å¸ƒå¤§åˆ™ maxOffsetX/Y = 0
    const maxOffsetX = Math.max(0, COLS - clipboard.w);
    const maxOffsetY = Math.max(0, ROWS - clipboard.h);

    // é’³åˆ¶åˆ° [0, maxOffset]
    pasteOffset = {
        x: Math.max(0, Math.min(maxOffsetX, desiredX)),
        y: Math.max(0, Math.min(maxOffsetY, desiredY))
    };

    selectionMode = 'paste';
    renderSelectionLayer();
}

/* ç§»åŠ¨é€‰åŒºï¼ˆå°†å½“å‰é€‰åŒºå†…å®¹å¤åˆ¶åˆ° clipboard, ç­‰å¾…ç²˜è´´ï¼›ç¡®è®¤ååŸä½æ¸…ç©ºï¼‰ */
function beginMove() {
    if (!selectionBounds) return alert('æ²¡æœ‰é€‰åŒº');
    // copy selection to clipboard
    moveBackup = [];

    const b = selectionBounds;
    const w = b.maxX - b.minX + 1, h = b.maxY - b.minY + 1;
    const cells = Array.from({length: h}, () => Array.from({length: w}, () => null));
    const origin = [];
    for (let y = b.minY; y <= b.maxY; y++) {
        for (let x = b.minX; x <= b.maxX; x++) {
            const k = `${x},${y}`;
            if (selectionPixels.has(k)) {
                cells[y - b.minY][x - b.minX] = pixelData[y][x];
                origin.push({x, y, oldColor: pixelData[y][x]});
            } else cells[y - b.minY][x - b.minX] = null;
        }
    }
    clipboard = {w, h, cells};
    pasteOffset = {x: b.minX, y: b.minY};

    moveOrigin = origin; // will be cleared on confirm
    selectionMode = 'move';

    const step = [];
    // å¦‚æœæ˜¯ move æ“ä½œ, æ¸…ç©ºåŸç‚¹ï¼ˆæŠŠoriginåƒç´ è®¾ä¸ºç©ºç™½ï¼‰
    if (moveOrigin && moveOrigin.length > 0) {
        moveOrigin.forEach(o => {
            // è‹¥åŸä½ç½®æ­£å¥½è¢«æ–°æ”¾ç½®è¦†ç›–ï¼ˆåæ ‡å†²çªï¼‰, oldColor already preserved; we still set to blank if not overlapped by new placement
            // For simplicity, set to palette[0] and record step
            step.push({x: o.x, y: o.y, oldColor: pixelData[o.y][o.x], newColor: colorPalette[0]});
            setPixelDirect(o.x, o.y, colorPalette[0]);
        });
    }
    if (step.length > 0) pushHistory(step);

    renderSelectionLayer();
}

/* ç¡®è®¤ç²˜è´´/ç§»åŠ¨ï¼šå†™å…¥åƒç´ å¹¶è®°å½•å†å²ï¼ˆç§»åŠ¨ä¼šåŒæ—¶æ¸…ç©ºåŸå¤„ï¼‰ */
function applyPaste() {
    if (!clipboard || !pasteOffset) return;
    const step = [];
    for (let sy = 0; sy < clipboard.h; sy++) {
        for (let sx = 0; sx < clipboard.w; sx++) {
            const col = clipboard.cells[sy][sx];
            if (col == null) continue;
            const tx = pasteOffset.x + sx, ty = pasteOffset.y + sy;
            if (tx < 0 || tx >= COLS || ty < 0 || ty >= ROWS) continue;
            step.push({x: tx, y: ty, oldColor: pixelData[ty][tx], newColor: col});
            setPixelDirect(tx, ty, col);
        }
    }

    if (step.length > 0) pushHistory(step);
    // æ¸…ç†
    // clipboard = null;
    pasteOffset = null;
    moveOrigin = null;
    selectionMode = null;
    setActiveSelection(null)
    selectionPixels.clear();
    updateSelectionBounds();
    renderSelectionLayer();
}

/* å–æ¶ˆé€‰åŒº/ç²˜è´´ */
function clearSelection() {
    // clipboard = null;
    selectionPixels.clear();
    selectionBounds = null;
    pasteOffset = null;
    moveOrigin = null;
    selectionMode = null;
    setActiveSelection(null)
    renderSelectionLayer();
}

/* ====== å†å²ï¼ˆæ’¤å›/é‡åšï¼‰ ====== */
function pushHistory(step) {
    if (!step || step.length === 0) return;
    historyStack.push(step);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
    redoStack = [];
}

function undo() {
    const step = historyStack.pop();
    if (!step) return;
    step.forEach(p => setPixelDirect(p.x, p.y, p.oldColor));
    redoStack.push(step);
}

function redo() {
    const step = redoStack.pop();
    if (!step) return;
    step.forEach(p => setPixelDirect(p.x, p.y, p.newColor));
    historyStack.push(step);
}

/* ====== å›¾å½¢å·¥å…·ï¼ˆpreview æ”¯æŒï¼‰ ====== */
function getLinePixels(x1, y1, x2, y2) {
    const pixels = [];
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    while (true) {
        pixels.push({x: x1, y: y1});
        if (x1 === x2 && y1 === y2) break;
        let e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
    return pixels;
}

function getRectPixels(x1, y1, x2, y2, hollow = false) {
    const pixels = [];
    const minX = Math.min(x1, x2), maxX = Math.max(x1, x2), minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
    for (let y = minY; y <= maxY; y++) for (let x = minX; x <= maxX; x++) {
        if (hollow) {
            if (x === minX || x === maxX || y === minY || y === maxY) pixels.push({x, y});
        } else pixels.push({x, y});
    }
    return pixels;
}

function getCirclePixels(cx, cy, r, hollow = false) {
    const pixels = [];
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const dist2 = dx * dx + dy * dy;
            if (hollow) {
                if (Math.abs(dist2 - r * r) <= Math.max(1, r)) pixels.push({x: cx + dx, y: cy + dy});
            } else {
                if (dist2 <= r * r) pixels.push({x: cx + dx, y: cy + dy});
            }
        }
    }
    return pixels;
}

/* ====== Flood Fill ====== */
function floodFill(x, y, targetColor, newColor, previewOnly = false) {
    if (targetColor === newColor) return [];
    const stack = [{x, y}];
    const visited = new Set();
    const pixels = [];
    while (stack.length) {
        const p = stack.pop();
        if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS) continue;
        const key = `${p.x},${p.y}`;
        if (visited.has(key)) continue;
        visited.add(key);
        if (pixelData[p.y][p.x] !== targetColor) continue;
        pixels.push({x: p.x, y: p.y});
        stack.push({x: p.x + 1, y: p.y});
        stack.push({x: p.x - 1, y: p.y});
        stack.push({x: p.x, y: p.y + 1});
        stack.push({x: p.x, y: p.y - 1});
    }
    if (previewOnly) return pixels;
    const step = [];
    pixels.forEach(p => {
        step.push({x: p.x, y: p.y, oldColor: pixelData[p.y][p.x], newColor});
        setPixelDirect(p.x, p.y, newColor);
    });
    if (step.length > 0) pushHistory(step);
    return pixels;
}

/* ====== é¢„è§ˆç»˜åˆ¶ï¼ˆç”»å›¾å½¢ï¼‰ ====== */
function renderPreview(pixels) {
    previewLayer.innerHTML = "";
    if (!pixels || pixels.length === 0) return;
    pixels.forEach(p => {
        const el = document.createElement("div");
        el.style.position = "absolute";
        el.style.width = PIXEL_SIZE + "px";
        el.style.height = PIXEL_SIZE + "px";
        el.style.left = (p.x * PIXEL_SIZE) + "px";
        el.style.top = (p.y * PIXEL_SIZE) + "px";
        el.style.backgroundColor = currentColor;
        el.style.opacity = 0.35;
        previewLayer.appendChild(el);
    });
}

/* ====== å¯¼å‡º/å¯¼å…¥ï¼ˆæ¢å¤åŸç‰ˆæ ¼å¼ï¼‰ ====== */
function exportAsText() {
    let out = "";
    for (let y = 0; y < ROWS; y++) {
        out += "- [";
        const row = [];
        for (let x = 0; x < COLS; x++) {
            const idx = colorPalette.indexOf(pixelData[y][x]);
            row.push(idx >= 0 ? idx.toString(16).toUpperCase() : "0");
        }
        out += row.join(", ") + "]\n";
    }
    exportOutput.value = out;

    // å°†ç»“æœå¤åˆ¶åˆ°å‰ªè´´æ¿
    navigator.clipboard.writeText(out).then(() => {
        showToast('å¯¼å‡ºçš„å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    }).catch(err => {
        showToast('æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿: ', err);
    });

}

function importFromText() {
    const text = exportOutput.value.trim();
    if (!text) {
        // å¦‚æœè¾“å…¥åŒºåŸŸä¸ºç©ºï¼Œå°è¯•ä»å‰ªè´´æ¿å¯¼å…¥
        navigator.clipboard.readText().then(clipboardText => {
            const trimmedText = clipboardText.trim();
            if (trimmedText) {
                try {
                    const lines = trimmedText.split("\n")
                        .map(l => l.trim())
                        .filter(l => l.length !== 0)
                        .map(line => line.replace(/^- +\[/, '').replace(/]$/, ''))
                        .filter(l => l.trim());
                    const newRows = lines.length;
                    const newCols = lines[0].split(",").length;

                    // è®¡ç®—åç§»é‡ï¼Œä»¥ä¾¿åœ¨æ–°ç”»å¸ƒä¸Šå±…ä¸­æ˜¾ç¤ºå›¾åƒ
                    let offsetX = Math.floor((COLS - newCols) / 2);
                    let offsetY = Math.floor((ROWS - newRows) / 2);

                    // å¦‚æœæ–°çš„å°ºå¯¸è¶…è¿‡äº†å½“å‰ç”»å¸ƒå°ºå¯¸ï¼Œè°ƒæ•´åç§»é‡
                    if (newCols > COLS) offsetX = 0;
                    if (newRows > ROWS) offsetY = 0;

                    const imported = [];
                    for (let y = 0; y < ROWS; y++) {
                        const row = [];
                        for (let x = 0; x < COLS; x++) {
                            // è®¡ç®—å¯¹åº”äºåŸå›¾çš„ä½ç½®
                            const srcX = x - offsetX;
                            const srcY = y - offsetY;

                            // å¦‚æœè¶…å‡ºåŸå›¾èŒƒå›´ï¼Œåˆ™å¡«å……èƒŒæ™¯è‰²
                            if (srcX < 0 || srcX >= newCols || srcY < 0 || srcY >= newRows) {
                                row.push(colorPalette[0]); // å‡è®¾ç´¢å¼•0ä¸ºèƒŒæ™¯è‰²
                            } else {
                                const v = lines[srcY].split(",")[srcX].trim().toUpperCase();
                                let idx = null;
                                if (/^[0-9A-F]$/.test(v)) idx = parseInt(v, 16); else idx = parseInt(v, 10);
                                if (isNaN(idx) || idx < 0 || idx >= colorPalette.length) throw new Error(`é¢œè‰²ç´¢å¼•æ— æ•ˆ: ${v}`);
                                row.push(colorPalette[idx]);
                            }
                        }
                        imported.push(row);
                        showToast('æˆåŠŸå¯¼å…¥ï¼');
                    }

                    // æ›´æ–°ç”»å¸ƒå°ºå¯¸
                    // document.getElementById("canvasWidth").value = COLS;
                    // document.getElementById("canvasHeight").value = ROWS;
                    pixelData = imported;
                    initCanvas();
                } catch (err) {
                    showToast("å¯¼å…¥å¤±è´¥: " + err.message);
                }
            } else {
                showToast("è¯·å…ˆç²˜è´´åƒç´ ç”»æ•°æ®");
            }
        }).catch(err => {
            console.error('æ— æ³•è¯»å–å‰ªè´´æ¿: ', err);
            showToast("æ— æ³•è¯»å–å‰ªè´´æ¿ï¼Œè¯·æ‰‹åŠ¨ç²˜è´´æ•°æ®");
        });
    } else {
        try {
            const lines = text.split("\n")
                .map(l => l.trim())
                .filter(l => l.length !== 0)
                .map(line => line.replace(/^- +\[/, '').replace(/]$/, ''))
                .filter(l => l.trim());
            const newRows = lines.length;
            const newCols = lines[0].split(",").length;

            // è®¡ç®—åç§»é‡ï¼Œä»¥ä¾¿åœ¨æ–°ç”»å¸ƒä¸Šå±…ä¸­æ˜¾ç¤ºå›¾åƒ
            let offsetX = Math.floor((COLS - newCols) / 2);
            let offsetY = Math.floor((ROWS - newRows) / 2);

            // å¦‚æœæ–°çš„å°ºå¯¸è¶…è¿‡äº†å½“å‰ç”»å¸ƒå°ºå¯¸ï¼Œè°ƒæ•´åç§»é‡
            if (newCols > COLS) offsetX = 0;
            if (newRows > ROWS) offsetY = 0;

            const imported = [];
            for (let y = 0; y < ROWS; y++) {
                const row = [];
                for (let x = 0; x < COLS; x++) {
                    // è®¡ç®—å¯¹åº”äºåŸå›¾çš„ä½ç½®
                    const srcX = x - offsetX;
                    const srcY = y - offsetY;

                    // å¦‚æœè¶…å‡ºåŸå›¾èŒƒå›´ï¼Œåˆ™å¡«å……èƒŒæ™¯è‰²
                    if (srcX < 0 || srcX >= newCols || srcY < 0 || srcY >= newRows) {
                        row.push(colorPalette[0]); // å‡è®¾ç´¢å¼•0ä¸ºèƒŒæ™¯è‰²
                    } else {
                        const v = lines[srcY].split(",")[srcX].trim().toUpperCase();
                        let idx = null;
                        if (/^[0-9A-F]$/.test(v)) idx = parseInt(v, 16); else idx = parseInt(v, 10);
                        if (isNaN(idx) || idx < 0 || idx >= colorPalette.length) throw new Error(`é¢œè‰²ç´¢å¼•æ— æ•ˆ: ${v}`);
                        row.push(colorPalette[idx]);
                    }
                }
                imported.push(row);
                showToast('æˆåŠŸå¯¼å…¥ï¼');
            }

            // æ›´æ–°ç”»å¸ƒå°ºå¯¸
            // document.getElementById("canvasWidth").value = COLS;
            // document.getElementById("canvasHeight").value = ROWS;
            pixelData = imported;
            initCanvas();
        } catch (err) {
            showToast("å¯¼å…¥å¤±è´¥: " + err.message);
        }
    }
}

function showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerText = message;

        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300); // ç­‰å¾…è¿‡æ¸¡æ•ˆæœå®Œæˆ
            }, 2000); // æ˜¾ç¤ºæ—¶é—´
        }, 10); // ç¡®ä¿å…ƒç´ è¢«æ·»åŠ åˆ°DOMåç«‹å³å¼€å§‹åŠ¨ç”»
    }

/* ====== æœ¬åœ°è‡ªåŠ¨ä¿å­˜/æ¢å¤ï¼ˆlocalStorageï¼‰ ====== */
const _LOCAL_KEY = 'pixelEditor:state:v1';

function saveCanvasToLocal() {
    try {
        const state = {
            COLS, ROWS,
            colorPalette,
            pixelData,
            currentMapping,
            currentColor,
            symmetryMode
        };
        localStorage.setItem(_LOCAL_KEY, JSON.stringify(state));
    } catch (err) {
        console.warn('ä¿å­˜æœ¬åœ°ç¼“å­˜å¤±è´¥', err);
    }
}

function loadCanvasFromLocal() {
    try {
        const raw = localStorage.getItem(_LOCAL_KEY);
        if (!raw) return false;
        const s = JSON.parse(raw);
        // æ¢å¤å°ºå¯¸ä¸è°ƒè‰²æ¿
        if (typeof s.COLS === 'number' && typeof s.ROWS === 'number') {
            COLS = s.COLS;
            ROWS = s.ROWS;
        }
        if (Array.isArray(s.colorPalette) && s.colorPalette.length > 0) {
            colorPalette = s.colorPalette.slice();
            basePalette = colorPalette.slice();
        }
        if (Array.isArray(s.currentMapping) && s.currentMapping.length === basePalette.length) {
            currentMapping = s.currentMapping.slice();
        } else {
            currentMapping = basePalette.slice();
        }
        if (Array.isArray(s.pixelData) && s.pixelData.length === ROWS) {
            // clone rows safely
            pixelData = s.pixelData.map(row => Array.isArray(row) ? row.slice() : Array.from({length: COLS}, () => colorPalette[0]));
        }
        if (s.currentColor) currentColor = s.currentColor;
        if (s.symmetryMode) symmetryMode = s.symmetryMode;

        // é‡æ–°æ¸²æŸ“ UI
        renderColorPalette();
        initRemapPanel();
        if (typeof refreshRemapGrid === 'function') refreshRemapGrid();
        initCanvas();
        if (typeof refreshSymmetry === 'function') refreshSymmetry();

        // showToast('å·²ä»æœ¬åœ°æ¢å¤ä¸Šæ¬¡ç”»å¸ƒ');
        return true;
    } catch (err) {
        console.warn('æ¢å¤æœ¬åœ°ç¼“å­˜å¤±è´¥', err);
        return false;
    }
}

// åœ¨é¡µé¢éšè—/å¸è½½æ—¶ä¿å­˜ç”»å¸ƒ
document.addEventListener('visibilitychange', () => {
    if (document.hidden) saveCanvasToLocal();
});
window.addEventListener('pagehide', saveCanvasToLocal);
// å…¼å®¹æ€§ï¼šåœ¨ beforeunload ä¹Ÿä¿å­˜ï¼ˆsetupEventListeners ä¸­ä¼šæç¤ºæ˜¯å¦ç¦»å¼€ï¼‰
window.addEventListener('beforeunload', saveCanvasToLocal);


/* ====== é¼ æ ‡åæ ‡æ˜ å°„ ====== */
function getPixelFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
    const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
    if (x >= 0 && x < COLS && y >= 0 && y < ROWS) return {x, y};
    return null;
}

/* ====== äº‹ä»¶å¤„ç† ====== */
let isDrawing = false;
let startX = null, startY = null;

function setupEventListeners() {
    // æ¢å¤ï¼šå…³é—­/åˆ·æ–°å‰æç¤ºï¼ˆåŸç‰ˆï¼‰
    window.addEventListener("beforeunload", (e) => {
        e.preventDefault();
        e.returnValue = "âš ï¸ æ•°æ®å°†ä¸ä¼šä¿å­˜, ç¡®å®šé€€å‡ºå—ï¼Ÿ";
    });

    function activateToolButton(btnId, toolName) {
        const btn = document.getElementById(btnId);
        btn.addEventListener("click", () => {
            tool = toolName;
            document.querySelectorAll(".btn-group button").forEach(b => b.classList.remove("active"));
            refreshSymmetry()
            btn.classList.add("active");
            previewLayer.innerHTML = "";
            startX = startY = null;
            isDrawing = false;
        });
    }

    activateToolButton("pen", "pen");
    activateToolButton("eraser", "eraser");
    activateToolButton("line", "line");
    activateToolButton("rect", "rect");
    activateToolButton("circle", "circle");
    activateToolButton("fill", "fill");
    activateToolButton("eyedropper", "eyedropper");

    // é€‰åŒºæŒ‰é’®ï¼ˆ+ hover æç¤ºï¼‰
    document.getElementById('selRect').addEventListener('click', () => {
        selectionMode = 'rect';
        selectionPixels.clear();
        selectionBounds = null;
        setActiveSelection('selRect');
        renderSelectionLayer();
    });

    document.getElementById('selFree').addEventListener('click', () => {
        selectionMode = 'free';
        selectionPixels.clear();
        selectionBounds = null;
        setActiveSelection('selFree');
        renderSelectionLayer();
    });
    document.getElementById('selMove').addEventListener('click', () => {
        if (!selectionBounds) return alert('å…ˆé€‰åŒºå†ç§»åŠ¨');
        beginMove();
    });
    document.getElementById('selCopy').addEventListener('click', () => {
        copySelection();
    });
    document.getElementById('selCut').addEventListener('click', () => {
        cutSelection();
    });
    document.getElementById('selPaste').addEventListener('click', () => {
        beginPaste();
    });
    document.getElementById('selClear').addEventListener('click', () => {
        clearSelection();
    });

    // æ’¤å›/é‡åš/æ¸…ç©º/å¯¼å‡º/å¯¼å…¥/æ·»åŠ é¢œè‰²/resize
    document.getElementById("undo").addEventListener("click", undo);
    document.getElementById("redo").addEventListener("click", redo);
    document.getElementById("clear").addEventListener("click", () => {
        if (!confirm("ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿ")) return;
        initData();
        initCanvas();
        historyStack = [];
        redoStack = [];
    });
    document.getElementById("toggleGrid").addEventListener("click", () => {
        const wrapper = document.getElementById("canvasWrapper");
        wrapper.classList.toggle("no-grid");
    });
    document.getElementById("exportBtn").addEventListener("click", exportAsText);
    document.getElementById("importBtn").addEventListener("click", importFromText);
    // ======= å¯¼å…¥å›¾ç‰‡ ======

    document.getElementById("importImage").addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/*";
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => importImageToCanvas(ev.target.result);
            reader.readAsDataURL(file);
        };
        input.click();
    });

    async function importImageToCanvas(dataUrl) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            // åˆ›å»ºç¦»å± canvas ç¼©æ”¾å›¾åƒ
            const off = document.createElement("canvas");
            off.width = COLS;
            off.height = ROWS;
            const ctx = off.getContext("2d", {willReadFrequently: true});
            ctx.imageSmoothingEnabled = false;//é‚»è¿‘ç¼©æ”¾
            ctx.drawImage(img, 0, 0, off.width, off.height);
            const imgData = ctx.getImageData(0, 0, off.width, off.height).data;

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const i = (y * COLS + x) * 4;
                    const r = imgData[i];
                    const g = imgData[i + 1];
                    const b = imgData[i + 2];
                    const color = rgbToHex(r, g, b);
                    const nearest = findNearestPaletteColor(colorPalette, color);
                    pixelData[y][x] = nearest;
                    const px = canvas.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                    if (px) px.style.backgroundColor = nearest;
                }
            }
        };
        img.src = dataUrl;
    }

    // å°† RGB è½¬ 16 è¿›åˆ¶
    function rgbToHex(r, g, b) {
        return "#" + [r, g, b].map(v => v.toString(16).padStart(2, "0")).join("");
    }

    // æŸ¥æ‰¾è°ƒè‰²æ¿ä¸­æœ€æ¥è¿‘çš„é¢œè‰²
    function findNearestPaletteColor(palette, targetHex) {
        const [r1, g1, b1] = hexToRgb(targetHex);
        let minDist = Infinity, nearest = palette[0];
        for (const c of palette) {
            const [r2, g2, b2] = hexToRgb(c);
            const d = (r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2;
            if (d < minDist) {
                minDist = d;
                nearest = c;
            }
        }
        return nearest;
    }

    // HEX è½¬ RGB
    function hexToRgb(hex) {
        const n = parseInt(hex.slice(1), 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }


    // ======= æ·»åŠ é¢œè‰² ======
    // document.getElementById("addColor").addEventListener("click", ()=>{
    //   const color = document.getElementById("colorPicker").value.toUpperCase();
    //   if (colorPalette.length >= colorPalette.length){} // noop (kept original behavior)
    //   if (!colorPalette.includes(color)){
    //     if (colorPalette.length >= 16){ alert("è°ƒè‰²æ¿å·²æ»¡"); return; }
    //     colorPalette.push(color);
    //     renderColorPalette();
    //     const last = colorPaletteContainer.querySelectorAll(".color-btn");
    //     last[last.length-1].click();
    //   } else alert("è¯¥é¢œè‰²å·²å­˜åœ¨");
    // });

    // document.getElementById("resizeCanvas").addEventListener("click", ()=>{
    //   const newW = parseInt(document.getElementById("canvasWidth").value);
    //   const newH = parseInt(document.getElementById("canvasHeight").value);
    //   if (newW>=5 && newW<=100 && newH>=5 && newH<=100){
    //     COLS = newW; ROWS = newH;
    //     initData(); initCanvas();
    //     historyStack=[]; redoStack=[];
    //   } else alert("å°ºå¯¸å¿…é¡»åœ¨5-100ä¹‹é—´");
    // });

    // symmetry
    document.querySelectorAll(".symmetry-btn").forEach(btn => {
        btn.addEventListener("click", function () {
            document.querySelectorAll(".symmetry-btn").forEach(b => b.classList.remove("active"));
            this.classList.add("active");
            symmetryMode = this.dataset.mode;
        });
    });
    document.querySelector('.symmetry-btn[data-mode="none"]').classList.add("active");

    // Canvas é¼ æ ‡é€»è¾‘
    // è§¦æ‘¸äº‹ä»¶å¤„ç†å‡½æ•°
    function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
            button: 0
        });
        canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {
            button: 0
        });
        document.dispatchEvent(mouseEvent);
    }

    // æ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬
    canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
    canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
    canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
    canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});

    canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        const pos = getPixelFromEvent(e);
        if (!pos) return;

        // é€‰åŒºæ¨¡å¼ï¼šçŸ©å½¢ / æ‰‹æ¶‚ / ç²˜è´´ç§»åŠ¨
        if (selectionMode === 'rect') {
            isSelecting = true;
            dragStart = pos;
            lastToggledKey = null;
            return;
        }
        if (selectionMode === 'free') {
            isSelecting = true;
            dragStart = pos;
            lastToggledKey = `${pos.x},${pos.y}`;
            toggleSelectionPixel(pos.x, pos.y);
            return;
        }
        if ((selectionMode === 'paste' || selectionMode === 'move') && clipboard) {
            isDraggingPaste = true;
            dragStart = pos;
            return;
        }

        // å¸¸è§„ç»˜å›¾
        if (tool === "pen" || tool === "eraser") {
            isDrawing = true;
            currentStep = [];
            drawPixel(pos.x, pos.y, null); // drawPixel è®°å½•åˆ° currentStep
            canvas._curStep = currentStep;
            return;
        }

        if (tool === "eyedropper") {
            if (!pos) return;
            const pickedColor = pixelData[pos.y][pos.x];
            if (pickedColor) {
                currentColor = pickedColor;
                document.querySelectorAll(".color-btn").forEach(x => x.classList.remove("selected"));
                const colorBtns = colorPaletteContainer.querySelectorAll(".color-btn");
                const idx = colorPalette.indexOf(pickedColor);
                if (colorBtns[idx]) colorBtns[idx].classList.add("selected");
            }
            previewLayer.innerHTML = "";
            return;
        }
        if (tool === "fill") {
            const targetColor = pixelData[pos.y][pos.x];
            const newColor = currentColor;
            if (targetColor !== newColor) {
                floodFill(pos.x, pos.y, targetColor, newColor, false);
            }
            previewLayer.innerHTML = "";
            return;
        }
        if (tool === "line" || tool === "rect" || tool === "circle") {
            startX = pos.x;
            startY = pos.y;
        }
    });

    canvas.addEventListener("mousemove", (e) => {
        const pos = getPixelFromEvent(e);
        if (!pos) return;
        currentMousePos = pos

        // çŸ©å½¢é€‰å–æ‹–åŠ¨ï¼šæŒ‰ Shift å åŠ ï¼ˆadd=trueï¼‰
        if (isSelecting && selectionMode === 'rect' && dragStart) {
            const add = e.shiftKey;
            setSelectionFromRect(dragStart.x, dragStart.y, pos.x, pos.y, add);
            return;
        }
        // æ‰‹æ¶‚é€‰å–ï¼šé€åƒç´ åˆ‡æ¢ï¼ˆè¿›å…¥æ–°åƒç´ æ‰åˆ‡æ¢ä¸€æ¬¡ï¼‰
        if (isSelecting && selectionMode === 'free') {
            const key = `${pos.x},${pos.y}`;
            if (key !== lastToggledKey) {
                toggleSelectionPixel(pos.x, pos.y);
                lastToggledKey = key;
            }
            return;
        }
        // ç²˜è´´/ç§»åŠ¨æ‹–åŠ¨é¢„è§ˆ
        if (isDraggingPaste && clipboard && (selectionMode === 'paste' || selectionMode === 'move')) {
            const dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            pasteOffset = {
                x: Math.max(-clipboard.w, Math.min(COLS, pasteOffset.x + dx)),
                y: Math.max(-clipboard.h, Math.min(ROWS, pasteOffset.y + dy))
            };
            dragStart = pos;
            renderSelectionLayer();
            return;
        }

        // ç»˜å›¾æ‹–åŠ¨
        if (isDrawing && (tool === "pen" || tool === "eraser")) {
            drawPixel(pos.x, pos.y, null);
            return;
        }

        // å½¢çŠ¶é¢„è§ˆ
        if (startX !== null && startY !== null) {
            const hollow = e.shiftKey;
            let pixels = [];
            if (tool === "line") pixels = getLinePixels(startX, startY, pos.x, pos.y);
            else if (tool === "rect") pixels = getRectPixels(startX, startY, pos.x, pos.y, hollow);
            else if (tool === "circle") {
                const r = Math.round(Math.sqrt((pos.x - startX) ** 2 + (pos.y - startY) ** 2));
                pixels = getCirclePixels(startX, startY, r, hollow);
            }
            renderPreview(pixels);
        }
    });

    document.addEventListener("mouseup", (e) => {
        const pos = getPixelFromEvent(e);

        // ç»“æŸé€‰åŒº
        if (isSelecting && selectionMode === 'rect') {
            isSelecting = false;
            dragStart = null;
            return;
        }
        if (isSelecting && selectionMode === 'free') {
            isSelecting = false;
            dragStart = null;
            lastToggledKey = null;
            return;
        }
        if (isDraggingPaste) {
            isDraggingPaste = false;
            dragStart = null;
            return;
        }

        // ç»˜å›¾ç»“æŸ -> å†å²è®°å½•
        if (isDrawing) {
            isDrawing = false;
            if (canvas._curStep && canvas._curStep.length > 0) {
                pushHistory(canvas._curStep);
                canvas._curStep = null;
                currentStep = null;
            }
        }

        // å½¢çŠ¶æäº¤
        if (startX !== null && startY !== null && pos) {
            const hollow = e.shiftKey;
            currentStep = [];
            if (tool === "line") {
                const pts = getLinePixels(startX, startY, pos.x, pos.y);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            } else if (tool === "rect") {
                const pts = getRectPixels(startX, startY, pos.x, pos.y, hollow);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            } else if (tool === "circle") {
                const r = Math.round(Math.sqrt((pos.x - startX) ** 2 + (pos.y - startY) ** 2));
                const pts = getCirclePixels(startX, startY, r, hollow);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            }
            if (currentStep && currentStep.length > 0) {
                pushHistory(currentStep);
                currentStep = null;
            }
        }

        startX = startY = null;
        previewLayer.innerHTML = "";
    });

    // é”®ç›˜ï¼šEnter ç¡®è®¤ç²˜è´´/ç§»åŠ¨ï¼›Esc æ¸…é™¤ï¼›Ctrl å¿«æ·é”®ï¼ˆä½†å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†/æ–‡æœ¬åŸŸ/å¯ç¼–è¾‘å…ƒç´ ä¸­åˆ™æ”¾è¡ŒåŸç”Ÿï¼‰
    document.addEventListener('keydown', (e) => {
        const tag = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
        const inInput = (tag === 'input' || tag === 'textarea' || document.activeElement && document.activeElement.isContentEditable);

        if (e.key === 'Enter') {
            if (selectionMode === 'paste' && clipboard) {
                applyPaste();
            } else if (selectionMode === 'move' && clipboard) {
                applyPaste();
            }
        }
        if (e.key === 'Escape') {
            clearSelection();
            previewLayer.innerHTML = "";
        }

        if (!inInput) {
            if (e.ctrlKey && e.key.toLowerCase() === 'c') {
                e.preventDefault();
                copySelection();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'x') {
                e.preventDefault();
                cutSelection();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                beginPaste();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            }
        }

        if ((e.key === 'Alt' || e.code === 'AltLeft' || e.code === 'AltRight') && !isColorPicking) {
            e.preventDefault();
            isColorPicking = true;
            previousTool = tool; // æ³¨æ„è¿™é‡Œæ”¹ä¸ºåˆ‡æ¢ä¸»å·¥å…·å˜é‡
            setActiveTool('eyedropper');
        }

        // é¿å…ä¸ç»„åˆé”®å†²çªï¼ˆCtrl/Meta/Altï¼‰
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        const k = e.key.toLowerCase();
        switch (k) {
            case 'b': // ç”»ç¬”
              e.preventDefault();
              setActiveTool('pen');
              break;
            case 'e': // æ©¡çš®
              e.preventDefault();
              setActiveTool('eraser');
              break;
            case 'm': // çŸ©å½¢é€‰åŒº
              e.preventDefault();
              // è§¦å‘å·²æœ‰æŒ‰é’®çš„è¡Œä¸ºä»¥ä¿æŒä¸€è‡´
              const selBtn = document.getElementById('selRect');
              if (selBtn) selBtn.click();
              break;
            case 'f': // å¡«å……
              e.preventDefault();
              setActiveTool('fill');
              break;
            case 'g': // åˆ‡æ¢ç½‘æ ¼
              e.preventDefault();
              const tg = document.getElementById('toggleGrid');
              if (tg) tg.click();
              break;
            default:
              break;
        }

    });

    document.addEventListener('keyup', (e) => {
        if ((e.key === 'Alt' || e.code === 'AltLeft' || e.code === 'AltRight') && isColorPicking) {
            isColorPicking = false;
            setActiveTool(previousTool || 'pen');
            previousTool = null;
        }
    });

    // ğŸ§­ é˜²æ­¢ Alt+Tab åå¡åœ¨å–è‰²æ¨¡å¼
    window.addEventListener("blur", () => {
        // å½“çª—å£å¤±ç„¦æ—¶æ ‡è®°çŠ¶æ€
        if (isColorPicking) {
            window._wasColorPicking = true;
        }
    });

    window.addEventListener("focus", () => {
        // å¦‚æœå¤±ç„¦æ—¶æ­£åœ¨å–è‰², åˆ™å¼ºåˆ¶æ¢å¤åŸå·¥å…·
        if (window._wasColorPicking) {
            window._wasColorPicking = false;
            isColorPicking = false;
            setActiveTool(previousTool || "pen");
            previousTool = null;
        }
    });


    // é˜²æ‹–æ‹½
    canvas.addEventListener("dragstart", (e) => {
        e.preventDefault();
        return false;
    });
}

/* ====== æ¸²æŸ“é¢œè‰²é¢æ¿ ====== */
function renderColorPalette() {
    colorPaletteContainer.innerHTML = "";
    colorPalette.forEach((c, i) => {
        const b = document.createElement("div");
        b.className = "color-btn";
        b.style.backgroundColor = c;
        b.dataset.color = c;
        b.title = `${i}: ${c}`;
        if (i === 3) b.classList.add("selected");
        b.addEventListener("click", () => {
            document.querySelectorAll(".color-btn").forEach(x => x.classList.remove("selected"));
            b.classList.add("selected");
            currentColor = c;
        });
        colorPaletteContainer.appendChild(b);
    });
    const info = document.createElement("div");
    info.style.cssText = "width:100%;text-align:center;margin-top:6px;font-size:12px;color:#666";
    //info.textContent = `${colorPalette.length} / 16 é¢œè‰²`;
    colorPaletteContainer.appendChild(info);
}

/* ====== åˆå§‹åŒ–å…¥å£ ====== */
(function initAll() {
    initData();
    renderColorPalette();
    initRemapPanel();
    initCanvas();
    loadCanvasFromLocal();
    setupEventListeners();
})();

function handleUnlockClick() {
    // æ‰“å¼€æ–°æ ‡ç­¾é¡µ
    window.open('https://live.bilibili.com/52030', '_blank');

    // è·å–æŒ‰é’®å…ƒç´ 
    var button = document.getElementById('unlock');

    // ä¿®æ”¹æŒ‰é’®æ–‡æœ¬
    button.textContent = 'å·²æ¿€æ´»';

    // ä¿®æ”¹æŒ‰é’®æ ·å¼
    button.style.backgroundColor = '#ccc';  // ç°è‰²èƒŒæ™¯
    button.style.color = '#666';            // æ·±ç°è‰²æ–‡å­—
    button.style.cursor = 'not-allowed';     // é¼ æ ‡æŒ‡é’ˆå˜ä¸ºä¸å…è®¸
    button.disabled = true;                 // ç¦ç”¨æŒ‰é’®

    spawnToyAvatar()
}

// ä¿è¯åªåˆ›å»ºä¸€æ¬¡
let _toyAvatarCreated = false;
let _audioCtx = null;

// ç”Ÿæˆå¹¶æ’­æ”¾ä¸€æ¬¡çŸ­ä¿ƒç©å¶å£°ï¼ˆåˆæˆï¼Œä¸ä¾èµ–éŸ³é¢‘æ–‡ä»¶ï¼‰
function playToySqueak() {
  try {
    if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const ctx = _audioCtx;

    const now = ctx.currentTime;

    // ä¸»éŸ³ï¼šå¿«é€Ÿä¸Šè¡Œé¢‘ç‡çš„æ­£å¼¦ï¼ˆsqueakï¼‰
    const osc = ctx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(1400, now + 0.12);

    // çŸ­åŒ…ç»œ
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0, now);
    g.gain.linearRampToValueAtTime(0.9, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

    // å åŠ ä¸€å±‚å™ªå£°ï¼ˆè½»å¾®æ°”å£°ï¼‰
    const bufferSize = 2 * ctx.sampleRate;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1600;
    noiseFilter.Q.value = 0.7;

    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.0005, now);
    ng.gain.exponentialRampToValueAtTime(0.05, now + 0.01);
    ng.gain.exponentialRampToValueAtTime(0.00001, now + 0.18);

    // æ··åˆè¾“å‡ºåˆ° destinationï¼ˆå¯åŠ ä¸ª compressor æˆ– master gainï¼‰
    const master = ctx.createGain();
    master.gain.value = 0.9;

    osc.connect(g);
    g.connect(master);

    noise.connect(noiseFilter);
    noiseFilter.connect(ng);
    ng.connect(master);

    master.connect(ctx.destination);

    osc.start(now);
    noise.start(now);

    osc.stop(now + 0.32);
    noise.stop(now + 0.32);

    // æ¸…ç†è¿æ¥ï¼ˆæµè§ˆå™¨ä¼šè‡ªåŠ¨é‡Šæ”¾æºï¼Œä½†åˆ‡æ–­å¼•ç”¨ä»¥ä¾¿ GCï¼‰
    setTimeout(()=> {
      try { osc.disconnect(); noise.disconnect(); g.disconnect(); ng.disconnect(); master.disconnect(); noiseFilter.disconnect(); } catch(e){}
    }, 500);
  } catch (err) {
    console.warn('Audio not available:', err);
  }
}

function spawnToyAvatar() {
  if (_toyAvatarCreated) return;
  _toyAvatarCreated = true;

  const avatar = document.createElement('div');
  avatar.id = 'toyAvatar';
  avatar.setAttribute('role','button');

  const hint = document.createElement('div');
  hint.className = 'hint';
  hint.textContent = 'ğŸµ';
  avatar.appendChild(hint);

  avatar.innerHTML += `<img src="./aza.webp" alt=""/>`;

  document.body.appendChild(avatar);

  avatar.addEventListener('click', (_) => {
    avatar.classList.remove('squeeze');
    void avatar.offsetWidth;
    avatar.classList.add('squeeze');
    playToySqueak();
  });
  avatar.addEventListener('mousedown', () => avatar.style.transform = 'scale(0.98)');
  avatar.addEventListener('mouseup', () => avatar.style.transform = '');
  avatar.addEventListener('mouseleave', () => avatar.style.transform = '');

}

</script>
<div style="text-align: center;">
    <a>
        &copy; 2025 Astrorbits NMBCTâ„¢ Â§AZAåœ£è¯æ´»åŠ¨ä¸“ç”¨Â§
    </a>
</div>
</body>
</html>
